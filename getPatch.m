function [AxonsPatch,AxonsPatchWithoutGap,AxonSegmentation,BoutonSegmentation,AxonsGTPoints,GapSize,XStart,YStart,XEnd,YEnd]...
    = getPatch(parameters)

% Main function for creating one image. The image is progressively filled
% with splines starting from an edge and moving towards another one.

% All the parameters are in the parameters structure. Their values can be
% modified in the parameters_structure_creation script, where they are also
% explained in details.

% Axon control points are generated by a random walk whose directions
% are controlled by a rejection sampling process to lie within a triangular
% region centred on the axis defined by the last step. Making "conformity"
% closer to 1 creates a set of control points that are more likely to lie
% in a straight line.

% Axon "Ground Truth" (AxonsGTPoints), in the form of a medial
% axis sampled at a much higher density than the control points (x10)
% through using spline (AxonPoly) interpolation. If an axon has several
% branches, new control points are generated starting from a point of the
% spline randomly picked.

% Several axons with several branches can be generated, and we can choose
% if they can cross each other by setting the crossingOK parameter value.

% Once all the splines are created, we determine the distance between each
% pixel in the image and its closest spline point. If the distance is below
% a certain threshold, then the pixel is colored according to this distance
% following a gaussian profile. We get the actual image (AxonsPatch) and
% its axon segmentation (AxonSegmentation).

% Then we modify the image by adding synapting boutons. We get the new
% image (AxonsPatch) and the bouton segmentation (BoutonSegmentation).

% Finally different sources of noise are added. First we add little circles
% representing cells that are often present whithin TPM images of neurons.
% We also add colored and white noise to the image.

% LIMITATIONS
% 1) Small probability for axons to cross near branching points 
% 2) Step Size between control points is not a function of resolution
% 3) Number of spline points is fixed regardless of the length of a branch
% 4) If "straightBranching" is too high, a lot of crossings will happen
% near branching areas, but if it's too low, then only right angle
% branchings will occur
% 5) If crossings aren't allowed, the time needed to generate an image is
% not linear with image complexity. (1 axon without branch will take 1s
% whereas 4 axons with each 4 branches will take around 45s sometimes more)
% 6) Only one type of synaptic boutons have been modelled


%%%%%%%%%%%%%%%%%%%%%%%%%%%% initialisation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%gets the value of each parameter in the parameters structure
[width,height, negative_image,...
    sigma_noise_min,sigma_noise_max,lambdaMin,lambdaMax,...
    MinAxons,MaxAxons,MinBran,MaxBran,...
    conformity,MinThickness, MaxThickness,MinGapSize,MaxGapSize,...
    StepSize,NSplinePoints,crossingOK,straightBranching,SegmentationThreshold,...
    sigma_spread,MinAxonIntensity,MaxAxonIntensity,MinPeriod,MaxPeriod,AxonProfile,BranchProfile,sigma_noise_axon,...
    MinNbBouton,MaxNbBouton,MinBouRadius,MaxBouRadius,MinBrightnessBouton,MaxBrightnessBouton,sigma_noise_bouton,...
    MinNbCircles,MaxNbCircles,CircleBrightness,MinBrightnessCircles,MaxBrightnessCircles,MinRadius,MaxRadius,sigma_noise_circle]...
    = getValues(parameters);

restart=0;
while restart==0
    NAxons = randi([MinAxons MaxAxons]);                 % number of axons
    NBran = randi([MinBran MaxBran],1,NAxons);           % numbers of branchse per axons
    thickness = randi([round(MinThickness*100),...
        round(MaxThickness*100)],1,sum(NBran))/100;      % thicknesses of the different branches
    GapSize = zeros(1,sum(NBran));                       % size of the gap in each branch
    TotalPoints = sum(NBran)*NSplinePoints;              % number of interpolating points
    AxonsGTPoints = zeros(5,TotalPoints);                % vector of the interpolating points
    variations = zeros(1,TotalPoints);                   % vector of the intensity variations
    pointer = 0;                                         % points to the current branch
    pointerAxon = 1;                                     % points to the start of the current axon in the GTPoints
    AxonsDistWithoutGap = Inf*ones(height,width);        % distance to the AxonsGTPoints without taking gaps into account
    AxonsDistWithGap = Inf*ones(height,width);           % distance to the AxonsGTPoints
    AxonsVariations = Inf*ones(height,width);            % describes intensity variations along axons taking gaps into account
    AxonsVariationsWithoutGap = Inf*ones(height,width);  % describes intensity variations but without gaps
    
    
    for z=1:NAxons
        
        %%%%%%%%%%%%%%%%%%%%%% mother branch of an axon %%%%%%%%%%%%%%%%%%%
        
        if z>1
            pointerAxon = pointerAxon+NBran(z-1)*NSplinePoints;
        end
        
        ncross = 0;
        cross = 1;
        while cross
            if crossingOK % if axons can cross we just get the starting point
                [Xstart,Ystart,v] = getstartcoords(width,height);%randomly select the starting point
                cross=0;
            else % if they can't then we need to check if the randomly picked starting point is not already
                %on an existing branch
                startOK = 0;
                while startOK==0
                    [Xstart,Ystart,v] = getstartcoords(width,height);%randomly select the starting point
                    if AxonsDistWithoutGap(Xstart,Ystart)==Inf %checks if it belongs to an existing branch
                        startOK = 1;
                    end
                end
            end
            if z==1
                XStart = Xstart; YStart = Ystart;
            end
            xp = Xstart; yp = Ystart; ControlPoints = [xp;yp];
            AtTerminalState = 0;   %reinitialize value for testing
            while ~AtTerminalState
                v  = getValidDirection(v,conformity);   %gets new direction
                xp = xp + StepSize*v(1);                %updates xp
                yp = yp + StepSize*v(2);                %updates yp
                AtTerminalState = (xp <= 1 | xp >= width | yp <= 1 | yp >= height); %checks if inside
                xp = min(xp,width); xp = max(xp,1);  %put xp at the border if it crossed it
                yp = min(yp,height); yp = max(yp,1);  %put yp at the border if it crossed it
                ControlPoints = [ControlPoints,[xp;yp]]; %stacks the new points inside a matrix
            end
            if z==1
                XEnd = ControlPoints(1,end); YEnd = ControlPoints(2,end); %gets the last point of the first axon
            end
            %creates a spline going through all the ControlPoints VesselPoly
            AxonPoly = MakeAxonPoly(ControlPoints);
            
            %matrix containing the points of the spline
            AxonsGTPoints(1:2,1+pointer*NSplinePoints:pointer*NSplinePoints+NSplinePoints) = getAxonsGTPoints(AxonPoly,NSplinePoints);
            AxonsGTPoints(3,1+pointer*NSplinePoints:pointer*NSplinePoints+NSplinePoints) =z ;
            AxonsGTPoints(4,1+pointer*NSplinePoints:pointer*NSplinePoints+NSplinePoints) = 1;
            AxonsGTPoints(5,1+pointer*NSplinePoints:pointer*NSplinePoints+NSplinePoints) = pointer+1;
            
            %fills the variation vector for this branch
            variations(1+pointer*NSplinePoints:NSplinePoints+pointer*NSplinePoints) = makeVariation...
                (randi([MinAxonIntensity,MaxAxonIntensity])/100,AxonProfile,NSplinePoints,MinAxonIntensity,...
                MaxAxonIntensity,MinPeriod,MaxPeriod);
            
            %gets the distance to the GTPoints of the pixels belonging to the
            %spline
            [BranchDistWithoutGap,BranchDistWithGap,BranchVariations,BranchVariationsWithoutGap,GapSize(1+pointer)] = PixDistanceToAxon...
                (width,height,AxonsGTPoints(1:2,1+pointer*NSplinePoints:pointer*NSplinePoints+NSplinePoints),...
                thickness(pointer+1),MinGapSize,MaxGapSize,...
                variations(1+pointer*NSplinePoints:NSplinePoints+pointer*NSplinePoints));
            
            %now we check if the spline crosses existing axons
            if ~crossingOK && isempty(find((BranchDistWithoutGap~=Inf & AxonsDistWithoutGap~=Inf),1))
                cross = 0;
            else ncross = ncross+1;
            end
            if ncross>50, restart = 1; end
            if restart==1, break, end
        end
        if restart==1, break, end
        
        %updates the AxonsDisthWithGap and the checking matrices (AxonsDistWithoutGap) with the new branch
        AxonsDistWithGap = min(AxonsDistWithGap,BranchDistWithGap);
        AxonsDistWithoutGap = min(AxonsDistWithoutGap,BranchDistWithoutGap);
        AxonsVariations = min(AxonsVariations,BranchVariations);
        AxonsVariationsWithoutGap = min(AxonsVariationsWithoutGap,BranchVariationsWithoutGap);
        
        pointer = pointer+1;
        
        
        %%%%%%%%%%%%%%%%%%%% daughter branches of an axon %%%%%%%%%%%%%%%%%%%%%
        % this section is similar to the previous one
        
        for i=2:NBran(z)
            cross=1;
            while cross
                s = randi([pointerAxon,pointerAxon+NSplinePoints*(i-1)]); %picks a starting point in the current axon
                newStart = AxonsGTPoints(1:2,s);                        %gets its coordinates
                xp = newStart(1); yp = newStart(2); ControlPoints = [xp;yp];
                AtTerminalState = 0;                                     %reinitialize value for testing
                while ~AtTerminalState
                    v  = getValidDirection(v,conformity);                %gets new direction
                    xp = xp + StepSize*v(1); yp = yp + StepSize*v(2);    %updates xp and yp
                    AtTerminalState = (xp <= 1 | xp >= width | yp <= 1 | yp >= height);
                    xp = min(xp,width);xp = max(xp,1);
                    yp = min(yp,height);yp = max(yp,1);
                    ControlPoints = [ControlPoints,[xp;yp]];
                end
                AxonPoly = MakeAxonPoly(ControlPoints);
                AxonsGTPoints(1:2,1+pointer*NSplinePoints:pointer*NSplinePoints+NSplinePoints) = getAxonsGTPoints(AxonPoly,NSplinePoints);
                AxonsGTPoints(3,1+pointer*NSplinePoints:pointer*NSplinePoints+NSplinePoints) = z;
                AxonsGTPoints(4,1+pointer*NSplinePoints:pointer*NSplinePoints+NSplinePoints) = i;
                AxonsGTPoints(5,1+pointer*NSplinePoints:pointer*NSplinePoints+NSplinePoints) = pointer+1;
                
                variations(1+pointer*NSplinePoints:NSplinePoints+pointer*NSplinePoints) = makeVariation...
                    (variations(s),BranchProfile,NSplinePoints,MinAxonIntensity,MaxAxonIntensity,MinPeriod,MaxPeriod);
                
                [BranchDistWithoutGap,BranchDistWithGap,BranchVariations,BranchVariationsWithoutGap,GapSize(1+pointer)] = PixDistanceToAxon(width,height,...
                    AxonsGTPoints(1:2,1+pointer*NSplinePoints:pointer*NSplinePoints+NSplinePoints),thickness(pointer+1),...
                    MinGapSize,MaxGapSize,variations(1+pointer*NSplinePoints:NSplinePoints+pointer*NSplinePoints));
                
                % checks if the new branch crosses already existing branches
                if crossingOK
                    cross = 0;
                    
                else
                    % as branches obviously cross their mother branch, we need a special function that checks the crossing only at
                    % a given distance from the branching point
                    cross=checkCrossings(AxonsDistWithoutGap,BranchDistWithoutGap,straightBranching*thickness(pointer+1),newStart);
                    if cross==1, ncross = ncross+1; end
                end
                if ncross>50, restart = 1; end
                if restart==1, break, end
            end
            if restart==1, break, end
            
            % updates the matrices with the new branch
            AxonsDistWithGap = min(AxonsDistWithGap,BranchDistWithGap);
            AxonsDistWithoutGap = min(AxonsDistWithoutGap,BranchDistWithoutGap);
            AxonsVariations = min(AxonsVariations,BranchVariations);
            AxonsVariationsWithoutGap = min(AxonsVariationsWithoutGap,BranchVariationsWithoutGap);
            
            pointer = pointer+1;
            
        end
        if restart==1, break, end
    end
    if restart==1, restart=0; continue,
    else restart = 1;
    end
end

%%%%%%%%%%%%%%% Obtaining the image from distance matrix %%%%%%%%%%%%%%%%%%

% gets a compatible version of AxonsVariations with VaryingIntensityWithDistance
AxonsVariations(AxonsVariations==Inf) = 0;
AxonsVariationsWithoutGap(AxonsVariationsWithoutGap==Inf) = 0;
% adds noise to the variations
AxonsVariations = AxonsVariations+sigma_noise_axon*randn(width,height);
% transforms distance into intensity, taking the variations into account
AxonsPatch = VaryingIntensityWithDistance(AxonsDistWithGap,'axons','gauss',sigma_spread,AxonsVariations);
% same but with the matrix without gaps
AxonsPatchWithoutGap = VaryingIntensityWithDistance(AxonsDistWithoutGap,'axons','gauss',sigma_spread,AxonsVariationsWithoutGap);
% gets the axon segmentation
AxonSegmentation = (AxonsDistWithoutGap <SegmentationThreshold);

%%%%%%%%%%%%%%%%%% adding circles representing boutons %%%%%%%%%%%%%%%%%%%%

%modifies the AxonPatch matrix to add boutons, and creates the bouton
%segmentation
[AxonsPatch,BoutonSegmentation] = getBoutons(AxonsPatch,AxonsGTPoints, MinNbBouton,MaxNbBouton, MinBouRadius, MaxBouRadius,...
    MinBrightnessBouton, MaxBrightnessBouton, sigma_noise_bouton, height, width, thickness);

%%%%%%%%%%%%%%%%%%% adding circles representing cells %%%%%%%%%%%%%%%%%%%%%

% modifies Axonspatch to add circles
[AxonsPatch, ~] = getCircles...
    (AxonsPatch,height,width,sigma_noise_circle,MinNbCircles,MaxNbCircles,CircleBrightness,...
    MinBrightnessCircles,MaxBrightnessCircles,MinRadius,MaxRadius);

%%%%%%%%%%%%%%%%%%%%%%%% adding different noises %%%%%%%%%%%%%%%%%%%%%%%%%%

% Add coloured and white noise to the image
sigma_noise = randi([round(sigma_noise_min*100000),round(sigma_noise_max*100000)])/100000;
lambda = randi([lambdaMin,lambdaMax]);
AxonsPatch = noise(AxonsPatch, sigma_noise, lambda, width, height);

%%%%%%%%%%%%%%%% Converting the data into greyscale images %%%%%%%%%%%%%%%%

AxonsPatchWithoutGap(AxonsPatchWithoutGap<0) = 0;
AxonsPatch = floor(AxonsPatch*255/max(max(AxonsPatch)));
AxonsPatchWithoutGap = floor(AxonsPatchWithoutGap*255/max(max(AxonsPatchWithoutGap)));
AxonSegmentation = 255*AxonSegmentation;
BoutonSegmentation = 255*BoutonSegmentation;

% take the negative of image
if negative_image
    AxonsPatch = 255*ones(width,height)-AxonsPatch;
    AxonsPatchWithoutGap = 255*ones(width,height)-AxonsPatchWithoutGap;
end

end

function [cross]=checkCrossings(AxonsDistWithoutGap,BranchDistWithoutGap,threshold,newStart)

% Checks that the new branch doesn't cross existing axons.
% We are forced to consider the case where a branch starts from another
% branch. Obviously the new branch crosses its mother branch. So we
% tolerate crossings in the vicinity of the branching point. Otherwise (if
% crossing occurs far from the branching point), it probably
% means the new branch crosses another branch.

cross = 1;
[row,col]=find(AxonsDistWithoutGap~=Inf & BranchDistWithoutGap~=Inf); %finds the pixels belonging to both branches

if isempty(row)
    cross=0;
else
    lIndices = length(row); %numbers of pixels common to both branches
    l = 1; %initialization
    while cross
        thisRow = row(l); thisCol = col(l);
        distToStartControlPoint = sqrt((newStart(1)-thisCol)^2+(newStart(2)-thisRow)^2); % distance to branching point
        if distToStartControlPoint>threshold
            break %two different branch cross,
        elseif l==lIndices
            cross=0; %if all the points are close enough then we consider that there is no crossing
        else
            l = l+1;
        end
    end
    
end

end

function dE = distE(X,Y,Point)
dE = sqrt((X(:)-Point(1)).^2+(Y(:)-Point(2)).^2);
end

function [AxonAxisGT] = getAxonsGTPoints(AxonsPoly,npoints)

% This function exctracts points from the spline

tt = linspace(0,1,npoints);
AxonAxisGT = fnval(AxonsPoly,tt); %find the value of the spline for all values of tt
AxonPolyDer = fnder(AxonsPoly,1); % differentiates VesselPoly
AxonDirGT = fnval(AxonPolyDer,tt); %find the values of the derivative at the spline points

end

function [AxonsPatch,BoutonSegmentation] = getBoutons(AxonsPatch,AxonsGTPoints, MinNbBou,MaxNbBou, MinBouRadius, MaxBouRadius,...
    MinBouBrightness, MaxBouBrightness, BouSigma, height, width, thickness)

% This function takes an image with axons as input and returns the same
% image with synaptic boutons having been added (AxonsPatch). The boutons
% are represented as circles. Their center is in the vicinity of a randomly
% picked spline point. The intensity of each pixel belonging to the bouton
% depends on its distance to the center (function
% VaryingIntensityWithDistance) with a gaussian profile. The average
% brightness is controlled by the parameter BouBrightness, and the expected
% variance (v) is calculated here.

% The function also returns the segmentation of the synaptic boutons
% (BoutonSegmentation).

NBou = randi([MinNbBou,MaxNbBou]);
BoutonSegmentation = zeros(height,width);

for I=1:NBou
    
    BouBrightness = randi([MinBouBrightness,MaxBouBrightness])/100;
    %radius = randi([MinBouRadius,MaxBouRadius]);
    Point = randi(length(AxonsGTPoints));
    center = round([AxonsGTPoints(1,Point),AxonsGTPoints(2,Point)]);
    radius = floor(thickness(AxonsGTPoints(5,Point)))+1;
    %dev = randi([-floor(thickness(AxonsGTPoints(3,Point))),floor(thickness(AxonsGTPoints(3,Point)))]);
    dev = 0;
    center = min(max(center+dev,1),width);
    
    if (center(1)-radius>0 && center(2)-radius>0 && center(1)+radius<=width && center(2)+radius<=height) %middle
        absInf=center(1)-radius; absSup=center(1)+radius; ordInf=center(2)-radius; ordSup=center(2)+radius;
        refAbs=radius+1; refOrd=radius+1;
        
    elseif (center(1)-radius<=0 && center(2)-radius<=0) %top left
        absInf=1; absSup=center(1)+radius; ordInf=1; ordSup=center(2)+radius;
        refAbs=center(1); refOrd=center(2);
        
    elseif (center(2)+radius>width && center(1)-radius<=0) %bottom left
        absInf=1; absSup=center(1)+radius; ordInf=center(2)-radius; ordSup=height;
        refAbs=center(1); refOrd=radius+1;
        
    elseif (center(2)-radius<=0 && center(1)+radius>height) %top right
        absInf=center(1)-radius; absSup=width; ordInf=1; ordSup=center(2)+radius;
        refAbs=radius+1; refOrd=center(2);
        
    elseif (center(1)+radius>width && center(2)+radius>height) %bottom right
        absInf=center(1)-radius; absSup=width; ordInf=center(2)-radius; ordSup=height;
        refAbs=radius+1; refOrd=radius+1;
        
    elseif (center(2)-radius<=0) %top
        absInf=center(1)-radius; absSup=center(1)+radius; ordInf=1; ordSup=center(2)+radius;
        refAbs=radius+1; refOrd=center(2);
        
    elseif (center(2)+radius>width) % bottom
        absInf=center(1)-radius; absSup=center(1)+radius; ordInf=center(2)-radius; ordSup=height;
        refAbs=radius+1; refOrd=radius+1;
        
    elseif (center(1)-radius<=0) %left
        absInf=1; absSup=center(1)+radius; ordInf=center(2)-radius; ordSup=center(2)+radius;
        refAbs=center(1); refOrd=radius+1;
        
    elseif (center(1)+radius>width) %right
        absInf=center(1)-radius; absSup=width; ordInf=center(2)-radius; ordSup=center(2)+radius;
        refAbs=radius+1; refOrd=radius+1;
    end
    
    [X,Y] = meshgrid(1:absSup-absInf+1,1:ordSup-ordInf+1);
    boutonDist = sqrt((X(:,:)-refAbs).^2+(Y(:,:)-refOrd).^2); %gets the distance to the center
    v = sqrt(-radius^2/(2*log(0.05/BouBrightness))); %std deviation used for the gaussian profile
    Indices = find(boutonDist>=radius); %gets the indice of the points belonging to the bouton
    for i = 1:length(Indices)
        thisRow = Y(Indices(i));
        thisCol = X(Indices(i));
        boutonDist(thisRow,thisCol) = Inf; %gets the distance for each point plus noise
    end
    bousegm = (boutonDist<Inf); % gets all the point of the bouton
    boutonDist = boutonDist+BouSigma*randn(ordSup-ordInf+1,absSup-absInf+1);
    boutonDist = VaryingIntensityWithDistance(boutonDist,'circle','gauss',v,0,BouBrightness); %gets the intensity of bouton
    AxonsPatch(ordInf:ordSup,absInf:absSup) = max(AxonsPatch(ordInf:ordSup,absInf:absSup),boutonDist); %puts back the bouton in the image
    BoutonSegmentation(ordInf:ordSup,absInf:absSup) = max(BoutonSegmentation(ordInf:ordSup,absInf:absSup),bousegm); %updates the BoutonSegmentation mask
end
BoutonSegmentation = logical(BoutonSegmentation);

end

function [NewAxonsPatch, NbCircles] = getCircles(AxonsPatch,height,width,sigma_noise_circle,MinNbCircles,MaxNbCircles,...
    CircleBrightness,MinBrightnessCircles,MaxBrightnessCircles,MinRadius,MaxRadius)

% This function takes an image as input and returns the same image with
% circles having been added. We randomly pick the center of the circle and
% its radius. Then we check that the corresponding location in the original
% image is empty. In that case we insert the circles after having added
% some noise to it.

% The intensity of a pixel is calculated by taking its distance to the
% center of the circle according to a gaussian profile.

% There are two sources of noise in this function. This first one consists
% to reset some pixel of the distance matrix to the radius value. This is
% done to mimick what is observed in real Two Photon Microscopy images
% (black dots). The second source of noise is simply a white noise.

% We have to consider the cases where the circle could be on one edge of
% the image (9 cases).

NewAxonsPatch = AxonsPatch;
NbCircles = randi([MinNbCircles,MaxNbCircles]);


for nbCircle=1:NbCircles
    
    cross = 1;
    radius = randi([MinRadius,MaxRadius]); %picks a radius
    SelectionPixel = randi([1,1+CircleBrightness]);
    brightness = randi([MinBrightnessCircles,MaxBrightnessCircles])/100; %picks the brightness of the circle
    
    while cross
        center=zeros(1,2);
        center(1)=randi(width); center(2)=randi(height); %defines the center of the circle
        
        if (center(1)-radius>0 && center(2)-radius>0 && center(1)+radius<=width && center(2)+radius<=height) %middle
            if AxonsPatch(center(2)-radius:center(2)+radius,center(1)-radius:center(1)+radius)==zeros(2*radius+1)
                cross=0;
                absInf=center(1)-radius; absSup=center(1)+radius; ordInf=center(2)-radius; ordSup=center(2)+radius;
                refAbs=radius+1; refOrd=radius+1;
            end
        elseif (center(1)-radius<=0 && center(2)-radius<=0) %top left
            if AxonsPatch(1:center(2)+radius,1:center(1)+radius)==zeros(center(2)+radius,center(1)+radius)
                cross=0;
                absInf=1; absSup=center(1)+radius; ordInf=1; ordSup=center(2)+radius;
                refAbs=center(1); refOrd=center(2);
            end
        elseif (center(2)+radius>width && center(1)-radius<=0) %bottom left
            if AxonsPatch(center(2)-radius:height,1:center(1)+radius)==zeros(radius+height-center(2)+1,center(1)+radius)
                cross=0;
                absInf=1; absSup=center(1)+radius; ordInf=center(2)-radius; ordSup=height;
                refAbs=center(1); refOrd=radius+1;
            end
        elseif (center(2)-radius<=0 && center(1)+radius>height) %top right
            if AxonsPatch(1:center(2)+radius,center(1)-radius:width)==zeros(center(2)+radius,radius+width-center(1)+1)
                cross=0;
                absInf=center(1)-radius; absSup=width; ordInf=1; ordSup=center(2)+radius;
                refAbs=radius+1; refOrd=center(2);
            end
        elseif (center(1)+radius>width && center(2)+radius>height) %bottom right
            if AxonsPatch(center(2)-radius:height,center(1)-radius:width)==...
                    zeros(radius+height-center(2)+1,radius+width-center(1)+1)
                cross=0;
                absInf=center(1)-radius; absSup=width; ordInf=center(2)-radius; ordSup=height;
                refAbs=radius+1; refOrd=radius+1;
            end
        elseif (center(2)-radius<=0) %top
            if AxonsPatch(1:center(2)+radius,center(1)-radius:center(1)+radius)==zeros(center(2)+radius,2*radius+1)
                cross=0;
                absInf=center(1)-radius; absSup=center(1)+radius; ordInf=1; ordSup=center(2)+radius;
                refAbs=radius+1; refOrd=center(2);
            end
            
        elseif (center(2)+radius>width) % bottom
            if AxonsPatch(center(2)-radius:height,center(1)-radius:center(1)+radius)==zeros(radius+height-center(2)+1,2*radius+1)
                cross=0;
                absInf=center(1)-radius; absSup=center(1)+radius; ordInf=center(2)-radius; ordSup=height;
                refAbs=radius+1; refOrd=radius+1;
            end
        elseif (center(1)-radius<=0) %left
            if AxonsPatch(center(2)-radius:center(2)+radius,1:center(1)+radius)==zeros(2*radius+1,center(1)+radius)
                cross=0;
                absInf=1; absSup=center(1)+radius; ordInf=center(2)-radius; ordSup=center(2)+radius;
                refAbs=center(1); refOrd=radius+1;
            end
        elseif (center(1)+radius>height) %right
            if AxonsPatch(center(2)-radius:center(2)+radius,center(1)-radius:width)==zeros(2*radius+1,radius+width-center(1)+1)
                cross=0;
                absInf=center(1)-radius; absSup=width; ordInf=center(2)-radius; ordSup=center(2)+radius;
                refAbs=radius+1; refOrd=radius+1;
            end
        end
        
    end
    
    [X,Y] = meshgrid(1:absSup-absInf+1,1:ordSup-ordInf+1);
    SelectionMatrix = randi(SelectionPixel,ordSup-ordInf+1,absSup-absInf+1); %matrix of integers between 1 and a set number
    dist = sqrt((X(:,:)-refAbs).^2+(Y(:,:)-refOrd).^2); %gets the distance to the center
    v = sqrt(-radius^2/(2*log(0.05/brightness))); % sigma coefficient for VaryingIntensityWithDistance
    IndicesSel = find(SelectionMatrix==SelectionPixel);
    IndicesRad = find(dist>radius);
    for i=1:length(IndicesSel)
        thisRow = Y(IndicesSel(i));
        thisCol = X(IndicesSel(i));
        dist(thisRow,thisCol) = radius; %reset the distance to radius in order to obtain black pixel in the circle
    end
    for i=1:length(IndicesRad)
        thisRow = Y(IndicesRad(i));
        thisCol = X(IndicesRad(i));
        dist(thisRow,thisCol)=Inf; %sets distance to Inf for pixel outside the circle range, they will be black
    end
    dist = dist+sigma_noise_circle*randn(ordSup-ordInf+1,absSup-absInf+1); %adds white noise to the circle
    dist = VaryingIntensityWithDistance(dist,'circle','gauss',v,0,brightness); %gets intensity out of distance
    NewAxonsPatch(ordInf:ordSup,absInf:absSup) = max...
        (NewAxonsPatch(ordInf:ordSup,absInf:absSup),dist); %puts back the circle in the Patch
    
end

end

function [StartX,StartY,u0] = getstartcoords(width,height)

% Randomly generates a starting on one of the four edges

whichside = randi(4,1); % One random number from 1 to 4

switch whichside
    case 1
        StartX = 1;
        StartY = randi([round(height/4),round(3*height/4)],1);
        u0 = [1,0];
    case 2
        StartX = randi([round(width/4),round(3*width/4)],1);
        StartY = 1;
        u0 = [0,1];
    case 3
        StartX = width;
        StartY = randi([round(height/4),round(3*height/4)],1);
        u0 = [-1,0];
    case 4
        StartX = randi([round(width/4),round(3*width/4)],1);
        StartY = height;
        u0 = [0,-1];
end
end

function u = getValidDirection(v, conformity)

%Gets a direction that more or less moves forward from the previous
%direction. Some deviation allowed as a straight tube vessel isn't
%interesting

%Increase if you want a straighter vessel.
%Decerease to make it curve more
v = v/norm(v); %normalize v
NoValidDirection = 1;
while NoValidDirection
    u = makerandunitdirvec(1);
    dp = v*u';
    if dp>conformity
        NoValidDirection = 0;
    end
end
end

function [width,height,negative_image,...
    sigma_noise_min,sigma_noise_max,lambdaMin,lambdaMax,...
    MinAxons,MaxAxons,MinBran,MaxBran,...
    conformity,MinThickness, MaxThickness,MinGapSize,MaxGapSize,...
    StepSize,NSplinePoints,crossingOK,straightBranching,SegmentationThreshold,...
    sigma_spread,MinAxonIntensity,MaxAxonIntensity,MinPeriod,MaxPeriod,AxonProfile,BranchProfile,sigma_noise_axon,...
    MinNbBouton,MaxNbBouton,MinBouRadius,MaxBouRadius,MinBrightnessBouton,MaxBrightnessBouton,sigma_noise_bouton,...
    MinNbCircles,MaxNbCircles,CircleBrightness,MinBrightnessCircles,MaxBrightnessCircles,MinRadius,MaxRadius,sigma_noise_circle]...
    = getValues(parameters)

% This function takes out the parameters from the structure

width = parameters(1).width;
height = parameters(1).height;
negative_image = parameters(1).negative_image;

sigma_noise_min = parameters(1).sigma_noise_min;
sigma_noise_max = parameters(1).sigma_noise_max;
lambdaMin = parameters(1).lambdaMin;
lambdaMax = parameters(1).lambdaMax;

MinAxons = parameters(1).MinAxons;
MaxAxons = parameters(1).MaxAxons;
MinBran = parameters(1).MinBran;
MaxBran = parameters(1).MaxBran;

conformity = parameters(1).conformity;
MinThickness = parameters(1).MinThickness;
MaxThickness = parameters(1).MaxThickness;
MinGapSize = parameters(1).MinGapSize;
MaxGapSize = parameters(1).MaxGapSize;

StepSize = parameters(1).StepSize;
NSplinePoints = parameters(1).NSplinePoints;
crossingOK = parameters(1).crossingOK;
straightBranching = parameters(1).straightBranching;
SegmentationThreshold = parameters(1).SegmentationThreshold;

sigma_spread = parameters(1).sigma_spread;
MinAxonIntensity = parameters(1).MinAxonIntensity;
MaxAxonIntensity = parameters(1).MaxAxonIntensity;
MinPeriod = parameters(1).MinPeriod;
MaxPeriod = parameters(1).MaxPeriod;
AxonProfile = parameters(1).AxonProfile;
BranchProfile = parameters(1).BranchProfile;
sigma_noise_axon = parameters(1).sigma_noise_axon;

MinNbBouton = parameters(1).MinNbBouton;
MaxNbBouton = parameters(1).MaxNbBouton;
MinBouRadius = parameters(1).MinBouRadius;
MaxBouRadius = parameters(1).MaxBouRadius;
MinBrightnessBouton  = parameters(1).MinBrightnessBouton;
MaxBrightnessBouton  = parameters(1).MaxBrightnessBouton;
sigma_noise_bouton = parameters(1).sigma_noise_bouton;

MinNbCircles = parameters(1).MinNbCircles;
MaxNbCircles = parameters(1).MaxNbCircles;
MinRadius = parameters(1).MinRadius;
MaxRadius = parameters(1).MaxRadius;
CircleBrightness = parameters(1).CircleBrightness;
MinBrightnessCircles = parameters(1).MinBrightnessCircles;
MaxBrightnessCircles = parameters(1).MaxBrightnessCircles;
sigma_noise_circle = parameters(1).sigma_noise_circle;

end

function AxonPoly = MakeAxonPoly(ControlPoints)

%creates a spline going trough all the ControlPoints

t = linspace(0,1,size(ControlPoints,2));%vector going from 0 to 1 with n evenly spaced values (n=#column of ControlP)
AxonPoly = csapi(t, ControlPoints); %csapi=spline, creates the spline

end

function u1 = makerandunitdirvec(N)
v = randn(N,2);
u1 = bsxfun(@rdivide,v,sqrt(sum(v.^2,2))); %normalize the vector v
end

function variation = makeVariation(startVariation,profileType,NSplinePoints,MinAxonIntensity,...
    MaxAxonIntensity,MinPeriod,MaxPeriod)

% This function generates vectors with values evolving according to a
% given profile. The length of this vector is the same as the number of
% spline points in a branch. Indeed each spline points will be associated
% with a multiplicative coefficient for its intensity.

switch profileType
    
    case {'constant'}
        variation = startVariation*ones(1,NSplinePoints);
        
    case {'linear'} %linear variation of intensity along the branch.
        upordown = randi(1); %intensity should increase or decrease from its starting point: 1=up 0=down
        if upordown
            MaxIntensity = randi([min(round(startVariation*10),MaxAxonIntensity*10-1),MaxAxonIntensity*10-1])/10;
            if startVariation~=MaxIntensity
                variation = startVariation:(MaxIntensity-startVariation)/(NSplinePoints-1):MaxIntensity;
            else
                variation = startVariation*ones(1,NSplinePoints);
            end
        else
            MinIntensity = randi([MinAxonIntensity*10+1,max(round(startVariation*10),MinAxonIntensity*10+1)])/10;
            if startVariation~=MinIntensity
                variation = startVariation:-(startVariation-MinIntensity)/(NSplinePoints-1):MinIntensity;
            else
                variation = startVariation*ones(1,NSplinePoints);
            end
        end
        
    case {'cosine'} %cosine variation of intensity along a branch
        NPeriods = randi([MinPeriod*100,MaxPeriod*100])/100;
        if startVariation<1, startVariation = startVariation*100; end
        MaxIntensity = randi([min(round(startVariation)-1,MaxAxonIntensity-1),MaxAxonIntensity-1])/100;
        MinIntensity = randi([MinAxonIntensity+1,max(round(startVariation)+1,MinAxonIntensity+1)])/100;
        a = 0.5*(MaxIntensity+MinIntensity); b = 0.5*(MaxIntensity-MinIntensity);
        %real part is due to no infinite calculation accuracy that leads to complex number for acos(1)
        phi = real(acos((round(startVariation)/100-a)/b));
        upordown = randi(1); %intensity should increase or decrease from its starting point: 1=up 0=down
        if upordown
            variation = a+b*cos((0:2*pi*NPeriods/(NSplinePoints-1):2*pi*NPeriods)-phi);
        else
            variation = a+b*cos((0:2*pi*NPeriods/(NSplinePoints-1):2*pi*NPeriods)+phi);
        end
        
end

end

function [BranchDistWithoutGap,BranchDistWithGap,BranchVariations,BranchVariationsWithoutGap,GapSize] = PixDistanceToAxon...
    (width,height,AxonGTPointsWithoutGap,thickness,MinGapSize,MaxGapSize,variations)

% This function finds the closest spline point for all the pixel in the
% image by calculating the distance between every pixel and every spline
% point. This returns a matrix (BranchDistWithGap) for which each pixel
% value is the distance to the closest GTPoint. A pixel is said to belong
% to an axon if its distance is below a given threshold. If a pixel is not
% part of an axon, its distance is set to +infinity.

% We also record to which AxonGTPoint a pixel has been associated. That way
% we can associate each pixel belonging to the branch to a variation
% coefficient. This coefficient will be used to calculate the pixel's
% intensity. So the function returns BranchVariations, describing the value
% of this coefficient for each point belonging to the axon.

% We also want to introduce gaps in each branch. This is done by erasing
% several GTPoints. The number of erased points is randomly picked. We have
% to deal with the fact that this gap can occur at the start, the middle,
% or the end of a branch.
% As we want use the distance matrix as a way to check is axons cross or
% not, we need to return a matrix without any gap (otherwise that would
% mean that axons could cross each other at the location of gaps). That is
% why we return two matrices containing distances: BranchDistWithoutGap and
% BranchDistWithGap.

NVesselCentrelinePoints = size(AxonGTPointsWithoutGap,2);
indicePoint = randi(size(AxonGTPointsWithoutGap,2)); % picks the gap middle point
GapSize = randi([MinGapSize,MaxGapSize]);
Case = 0;
BranchDistWithoutGap = Inf*ones(width,height);  % Create a vessel dist with "inf"
BranchDistWithGap = Inf*ones(width,height);
BranchVariations = Inf(width,height);
[X,Y] = meshgrid(1:width,1:height);

if GapSize>0
    if indicePoint>GapSize && indicePoint<NVesselCentrelinePoints-GapSize
        Case = 1; %gap in the middle
    elseif indicePoint<=GapSize
        Case = 2; %the axon starts by a gap
    elseif indicePoint>=NVesselCentrelinePoints-GapSize
        Case = 3; %the axon ends by a gap
    end
end

switch(Case)
    
    case 0 %no gap
        % For each point on vessel
        for n = 1:NVesselCentrelinePoints
            
            DistWithoutGap = distE(X,Y,AxonGTPointsWithoutGap(:,n)); %gets distance between a GT point and all the pixels
            IndicesInImageWithoutGap = find(DistWithoutGap<thickness); %gets the indices of the closest points
            if ~isempty(IndicesInImageWithoutGap)
                for i = 1:length(IndicesInImageWithoutGap)
                    thisRow = Y(IndicesInImageWithoutGap(i));
                    thisCol = X(IndicesInImageWithoutGap(i));
                    a = min(BranchDistWithoutGap(thisRow,thisCol),DistWithoutGap(IndicesInImageWithoutGap(i)));
                    if a==DistWithoutGap(IndicesInImageWithoutGap(i)) %checks if the distance if inferior to smallest distance calculated yet
                        BranchDistWithoutGap(thisRow,thisCol) = a; %in the corresponding pixel value is set to that distance
                        BranchVariations(thisRow,thisCol) = variations(n); %and the correpsonding multiplicative coef is also inserted
                    end
                end
            end
        end
        BranchDistWithGap = BranchDistWithoutGap; %as there is no gap the two matrices are the same
        BranchVariationsWithoutGap = BranchVariations;
        
    case 1 %gap in the middle
        %first part of the axon
        for n=1:indicePoint-GapSize-1
            DistWithoutGap = distE(X,Y,AxonGTPointsWithoutGap(:,n)); %gets distance between a GTPoint and all the pixels
            IndicesInImageWithoutGap = find(DistWithoutGap<thickness); %gets the indices of the points whose distance is inferior to thickness
            if ~isempty(IndicesInImageWithoutGap)
                for i = 1:length(IndicesInImageWithoutGap)
                    thisRow = Y(IndicesInImageWithoutGap(i));
                    thisCol = X(IndicesInImageWithoutGap(i));
                    a = min(BranchDistWithoutGap(thisRow,thisCol),DistWithoutGap(IndicesInImageWithoutGap(i)));
                    if a==DistWithoutGap(IndicesInImageWithoutGap(i)) %checks if the distance if inferior to smallest distance calculated yet
                        BranchDistWithoutGap(thisRow,thisCol) = a; %if minimum then
                        BranchVariations(thisRow,thisCol) = variations(n);
                    end
                end
            end
        end
        %last part of the axon
        for n=indicePoint+GapSize+1:NVesselCentrelinePoints
            DistWithoutGap = distE(X,Y,AxonGTPointsWithoutGap(:,n));
            IndicesInImageWithoutGap = find(DistWithoutGap<thickness);
            if ~isempty(IndicesInImageWithoutGap)
                for i = 1:length(IndicesInImageWithoutGap)
                    thisRow = Y(IndicesInImageWithoutGap(i));
                    thisCol = X(IndicesInImageWithoutGap(i));
                    a = min(BranchDistWithoutGap(thisRow,thisCol),DistWithoutGap(IndicesInImageWithoutGap(i)));
                    if a==DistWithoutGap(IndicesInImageWithoutGap(i))
                        BranchDistWithoutGap(thisRow,thisCol) = a;
                        BranchVariations(thisRow,thisCol) = variations(n);
                    end
                end
            end
        end
        BranchDistWithGap = BranchDistWithoutGap; %as there is no gap in these parts the two matrices are the same up to this point
        BranchVariationsWithoutGap = BranchVariations;
        % but now there's a difference for the middle part (ie where the gap is) so we
        % calculate the distance only for the axon without gap
        for n=indicePoint-GapSize:indicePoint+GapSize
            DistWithoutGap = distE(X,Y,AxonGTPointsWithoutGap(:,n));
            IndicesInImageWithoutGap = find(DistWithoutGap<thickness); %gets the indices of the closest points
            if ~isempty(IndicesInImageWithoutGap)
                for i = 1:length(IndicesInImageWithoutGap)
                    thisRow = Y(IndicesInImageWithoutGap(i));
                    thisCol = X(IndicesInImageWithoutGap(i));
                    a = min(BranchDistWithoutGap(thisRow,thisCol),DistWithoutGap(IndicesInImageWithoutGap(i)));
                    if a==DistWithoutGap(IndicesInImageWithoutGap(i))
                        BranchDistWithoutGap(thisRow,thisCol) = a; %distance
                        BranchVariationsWithoutGap(thisRow,thisCol) = variations(n);
                    end
                end
            end
        end
        
    case 2 %the axon starts by a gap
        for n = indicePoint+GapSize+1:NVesselCentrelinePoints %last part of the axon (without gap)
            DistWithoutGap = distE(X,Y,AxonGTPointsWithoutGap(:,n));
            IndicesInImageWithoutGap = find(DistWithoutGap<thickness); %gets the indices of the closest points
            if ~isempty(IndicesInImageWithoutGap)
                for i = 1:length(IndicesInImageWithoutGap)
                    thisRow = Y(IndicesInImageWithoutGap(i));
                    thisCol = X(IndicesInImageWithoutGap(i));
                    a = min(BranchDistWithoutGap(thisRow,thisCol),DistWithoutGap(IndicesInImageWithoutGap(i)));
                    if a==DistWithoutGap(IndicesInImageWithoutGap(i))
                        BranchDistWithoutGap(thisRow,thisCol) = a; %distance
                        BranchVariations(thisRow,thisCol) = variations(n);
                    end
                end
            end
        end
        BranchDistWithGap = BranchDistWithoutGap; %as there is no gap in this part the two matrices are the same up to this point
        BranchVariationsWithoutGap = BranchVariations;
        for n = 1:indicePoint+GapSize %gap part
            DistWithoutGap = distE(X,Y,AxonGTPointsWithoutGap(:,n));
            IndicesInImageWithoutGap = find(DistWithoutGap<thickness); %gets the indices of the closest points
            if ~isempty(IndicesInImageWithoutGap)
                for i = 1:length(IndicesInImageWithoutGap)
                    thisRow = Y(IndicesInImageWithoutGap(i));
                    thisCol = X(IndicesInImageWithoutGap(i));
                    a = min(BranchDistWithoutGap(thisRow,thisCol),DistWithoutGap(IndicesInImageWithoutGap(i)));
                    if a==DistWithoutGap(IndicesInImageWithoutGap(i))
                        BranchDistWithoutGap(thisRow,thisCol) = a; %distance
                        BranchVariationsWithoutGap(thisRow,thisCol) = variations(n);
                    end
                end
            end
        end
        
    case 3 %the axon ends by a gap
        %first part
        for n = 1:indicePoint-GapSize-1
            DistWithoutGap = distE(X,Y,AxonGTPointsWithoutGap(:,n));
            IndicesInImageWithoutGap = find(DistWithoutGap<thickness); %gets the indices of the closest points
            if ~isempty(IndicesInImageWithoutGap)
                for i = 1:length(IndicesInImageWithoutGap)
                    thisRow = Y(IndicesInImageWithoutGap(i));
                    thisCol = X(IndicesInImageWithoutGap(i));
                    a=min(BranchDistWithoutGap(thisRow,thisCol),DistWithoutGap(IndicesInImageWithoutGap(i)));
                    if a==DistWithoutGap(IndicesInImageWithoutGap(i))
                        BranchDistWithoutGap(thisRow,thisCol) = a; %distance
                        BranchVariations(thisRow,thisCol) = variations(n);
                    end
                end
            end
        end
        BranchDistWithGap = BranchDistWithoutGap;
        BranchVariationsWithoutGap = BranchVariations;
        for n = indicePoint+GapSize:NVesselCentrelinePoints %last part with gap
            DistWithoutGap = distE(X,Y,AxonGTPointsWithoutGap(:,n));
            IndicesInImageWithoutGap = find(DistWithoutGap<thickness); %gets the indices of the closest points
            if ~isempty(IndicesInImageWithoutGap)
                for i = 1:length(IndicesInImageWithoutGap)
                    thisRow = Y(IndicesInImageWithoutGap(i));
                    thisCol = X(IndicesInImageWithoutGap(i));
                    a=min(BranchDistWithoutGap(thisRow,thisCol),DistWithoutGap(IndicesInImageWithoutGap(i)));
                    if a==DistWithoutGap(IndicesInImageWithoutGap(i))
                        BranchDistWithoutGap(thisRow,thisCol) = a; %distance
                        BranchVariationsWithoutGap(thisRow,thisCol) = variations(n);
                    end
                end
            end
        end
end

end

function I = VaryingIntensityWithDistance(d,StructureType,IntProfileType,sigma_spread,AxonsVariations,brightness)

% Function to take an n-dimensional array of distances to centreline (d)
% and to return an array, I, of the same size and dimensions of d in which
% the values in the array are a function of d.
% Current options include a Butterworth, a Gaussian and a flat profile.
% We differenciate two cases: intensity along an axon that varies according
% AxonVariations, and intensity for circles.


switch StructureType
    
    case {'axons'}
        switch lower(IntProfileType)
            case {'butter','butterworth'}
                I = 1./(1+(d/2).^4); % 4th order Butterworth, radius of vessel of around 2
            case {'flat'}
                I = abs(d)<2;
            case {'gaussian','gauss'}
                I = exp(-d.^2/(2*sigma_spread^2))/sqrt(2*pi*sigma_spread^2).*AxonsVariations;
        end
        
    case {'circle'}
        switch lower(IntProfileType)
            case {'butter','butterworth'}
                I = 1./(1+(d/2).^4); % 4th order Butterworth, radius of vessel of around 2
            case {'flat'}
                I = abs(d)<2;
            case {'gaussian','gauss'}
                I = exp(-d.^2/(2*sigma_spread^2))*brightness;
        end
        
        
end


end

function Patch = noise (Patch,sigmawn,lambda,height,width)

% this function takes a clean patch as input. It models all the noise
% occuring the acquisition procedure (optic blurring, photon emmissions,
% electronic noise). Its output is a grayscale image with values between 0
% and 255.

sigma1 = 0.1;
sigma2 = 6;

size1 = 2;
size2 = 50;

Patch = floor(Patch*255/max(max(Patch)));
Poisson = poissrnd(lambda,height,width);
Gauss = sigmawn * randn(height,width);
Oblur1 = fspecial('gaussian', size1, sigma1);
Oblur2 = 25*fspecial('gaussian', size2, sigma2);

Patch = imfilter(Patch,Oblur1,'replicate') + imfilter(Poisson,Oblur2,'replicate') + Gauss;
Patch(Patch<0) = 0;
Patch = floor(Patch*255/max(max(Patch)));

end